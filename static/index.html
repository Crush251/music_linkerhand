<!--
  钢琴演奏控制系统主页面
  - 支持多CAN设备的手部和机械臂控制
  - 动态生成设备面板，支持多种控制模式

  明天工作：
  1. 手部控制：
    灵巧手原子操作序列控制

  2. 机械臂控制：
    机械臂原子操作序列控制

3.混合序列解析控制

-->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎹 钢琴演奏控制系统</title>
   <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <h1>🎹 钢琴演奏控制系统</h1>

        
        <div class="control-section">
            <h3>🔌 CAN接口配置</h3>
            <div class="connection-info">
                <strong>可用CAN接口:</strong>
                <div class="interface-list" id="interfaceList">
                    <span>检测中...</span>
                </div>
            </div>
            <button class="btn" onclick="refreshInterfaces()">刷新接口</button>
        </div>

        <div id="canDevicesContainer" class="can-devices-grid"></div>
    </div>

    <script>
        // ===================== 全局变量和初始化 =====================
        // canInterfaces: 存储后端返回的可用CAN接口
        // canDeviceConfigs: 存储每个面板的配置（接口、类型等）
        const canInterfaces = [];
        const canDeviceConfigs = {};
        
        // 页面加载时自动刷新接口并生成面板
        document.addEventListener('DOMContentLoaded', function() {
            refreshInterfaces();
        });

        // ===================== 消息与状态栏 =====================
      

        // ===================== CAN接口与设备面板 =====================
        // 刷新接口并生成设备面板
        async function refreshInterfaces() {
            try {
                const response = await fetch('/api/can_interfaces');
                const data = await response.json();
                canInterfaces.length = 0;
                canInterfaces.push(...(data.interfaces || []));
                
                const interfaceList = document.getElementById('interfaceList');
                if (canInterfaces.length > 0) {
                    interfaceList.innerHTML = canInterfaces.map(iface => 
                        `<span class="interface-tag">${iface}</span>`
                    ).join('');
                } else {
                    interfaceList.innerHTML = '<span>未检测到接口</span>';
                }
                
                initializeCanDevices(canInterfaces.length);//canInterfaces.length是后端返回的可用CAN接口数量
            } catch (error) {
                showMessage('获取CAN接口失败: ' + error.message, 'error');
            }
        }

        // 动态生成CanDevLen个CAN设备面板
        function initializeCanDevices(CanDevLen) {
            const container = document.getElementById('canDevicesContainer');
            container.innerHTML = '';
            
            for (let i = 0; i < CanDevLen; i++) {
                const deviceDiv = document.createElement('div');
                deviceDiv.className = 'can-device-panel';
                deviceDiv.innerHTML = `
                    <div class="device-header">
                        <h3>CAN设备 ${i + 1}</h3>
                        <div class="device-config">
                            <select id="canSelect${i}" onchange="onCanInterfaceChange(${i})">
                                <option value="">选择CAN接口</option>
                                ${canInterfaces.map(iface => `<option value="${iface}">${iface}</option>`).join('')}
                            </select>
                            <select id="deviceType${i}" onchange="onDeviceTypeChange(${i})" disabled>
                                <option value="">选择设备类型</option>
                                <option value="hand">手部控制</option>
                                <option value="arm">机械臂</option>
                            </select>
                        </div>
                    </div>
                    <div id="deviceContent${i}" class="device-content"></div>
                `;
                container.appendChild(deviceDiv);
            }
        }

        // 选择CAN接口后启用设备类型选择
        function onCanInterfaceChange(deviceIndex) {
            const canSelect = document.getElementById(`canSelect${deviceIndex}`);
            const deviceTypeSelect = document.getElementById(`deviceType${deviceIndex}`);
            
            if (canSelect.value) {
                deviceTypeSelect.disabled = false;
            } else {
                deviceTypeSelect.disabled = true;
                deviceTypeSelect.value = '';
                onDeviceTypeChange(deviceIndex);
            }
        }

        // 选择设备类型后渲染对应内容
        function onDeviceTypeChange(deviceIndex) {
            const canSelect = document.getElementById(`canSelect${deviceIndex}`);
            const deviceTypeSelect = document.getElementById(`deviceType${deviceIndex}`);
            const contentDiv = document.getElementById(`deviceContent${deviceIndex}`);
            
            if (!canSelect.value || !deviceTypeSelect.value) {
                contentDiv.innerHTML = '';
                return;
            }

            const canInterface = canSelect.value;
            const deviceType = deviceTypeSelect.value;
            
            canDeviceConfigs[deviceIndex] = {
                canInterface: canInterface,
                deviceType: deviceType
            };

            if (deviceType === 'hand') {
                renderHandControl(deviceIndex, contentDiv);
            } else if (deviceType === 'arm') {
                renderArmControl(deviceIndex, contentDiv);
            }
        }

        // ===================== 手部控制相关 =====================
        // 渲染手部控制区
        function renderHandControl(deviceIndex, contentDiv) {
            contentDiv.innerHTML = `
                <div class="hand-control">
                    <div class="hand-type-selection">
                        <label>
                            <input type="radio" name="handType${deviceIndex}" value="left" onchange="onHandTypeChange(${deviceIndex})"> 左手
                        </label>
                        <label>
                            <input type="radio" name="handType${deviceIndex}" value="right" onchange="onHandTypeChange(${deviceIndex})"> 右手
                        </label>
                    </div>
                    <div id="handContent${deviceIndex}" class="hand-content"></div>
                </div>
            `;
        }

        // 选择左/右手后渲染原子操作和滑块
        function onHandTypeChange(deviceIndex) {
            const handType = document.querySelector(`input[name="handType${deviceIndex}"]:checked`)?.value;
            const handContentDiv = document.getElementById(`handContent${deviceIndex}`);
            
            if (!handType) {
                handContentDiv.innerHTML = '';
                return;
            }

            canDeviceConfigs[deviceIndex].handType = handType;
            const canId = handType === 'left' ? '0x28' : '0x27';
            
            handContentDiv.innerHTML = `
                <div class="atomic-control">
                    <h4>原子操作控制</h4>
                    <label>原子操作输入（小指4,无名指3,中指2,食指1,大拇指0）:</label>
                    <textarea id="atomicInput${deviceIndex}" rows="4" style="width:100%;">[
    [[1,4],[0.1,1]],
    [[1,4,2],[0.1,0.3,0.5]],
    [[1],[0.2]],
    [[1],[0.2]]
]</textarea>
                    <button onclick="sendAtomicAction(${deviceIndex})">发送原子动作</button>
                </div>

                <div class="slider-control">
                    <h4>手指控制</h4>
                    <div class="mode-selector">
                        <label>
                            <input type="radio" name="controlMode${deviceIndex}" value="0x01" checked> 弯曲控制
                        </label>
                        <label>
                            <input type="radio" name="controlMode${deviceIndex}" value="0x05"> 速度控制
                        </label>
                    </div>
                    <div id="fingerSliders${deviceIndex}"></div>
                </div>
                <button onclick="updateFingersPianoPreset(${deviceIndex})">更新弹琴预设值</button>
            `;
            // 初始化手指滑块
            initFingerSliders(deviceIndex);
 
        }

        // 初始化手指滑块
        function initFingerSliders(deviceIndex) {
            const fingerNames = [
                "拇指弯曲", "拇指根部左右", "食指弯曲", "中指弯曲", 
                "无名指弯曲", "小拇指弯曲", "大拇指上下"
            ];
            
            const slidersContainer = document.getElementById(`fingerSliders${deviceIndex}`);
            slidersContainer.innerHTML = '';
            
            fingerNames.forEach((name, index) => {
                const container = document.createElement('div');
                container.className = 'slider-container';
                
                const label = document.createElement('div');
                label.className = 'slider-label';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'finger-name';
                nameSpan.textContent = name;
                
                const valueSpan = document.createElement('span');
                valueSpan.className = 'value';
                valueSpan.textContent = '128';
                
                const inputBox = document.createElement('input');
                inputBox.type = 'number';
                inputBox.min = '0';
                inputBox.max = '255';
                inputBox.value = '128';
                inputBox.className = 'value-input';
                inputBox.addEventListener('input', function() {
                    const value = Math.max(0, Math.min(255, parseInt(this.value) || 0));
                    this.value = value;
                    slider.value = value;
                    valueSpan.textContent = value;
                    sendFingerControl(deviceIndex);
                });
                
                label.appendChild(nameSpan);
                label.appendChild(valueSpan);
                label.appendChild(inputBox);
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = '0';
                slider.max = '255';
                slider.value = '128';
                slider.dataset.index = index;
                
                slider.addEventListener('input', function() {
                    const value = this.value;
                    valueSpan.textContent = value;
                    inputBox.value = value;
                });
                
                slider.addEventListener('change', function() {
                    sendFingerControl(deviceIndex);
                });
                
                container.appendChild(label);
                container.appendChild(slider);
                slidersContainer.appendChild(container);
            });
        }

        // 发送手指滑块控制指令
        async function sendFingerControl(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            const mode = document.querySelector(`input[name="controlMode${deviceIndex}"]:checked`).value;
            const sliders = document.querySelectorAll(`#fingerSliders${deviceIndex} input[type="range"]`);
            
            const data = [parseInt(mode, 16)];
            sliders.forEach(slider => {
                data.push(parseInt(slider.value));
            });
            
            while (data.length < 8) {
                data.push(0);
            }
            
            const canMessage = {
                interface: config.canInterface,
                id: config.handType === 'left' ? 0x28 : 0x27,
                data: data
            };
            
            try {
                const response = await fetch('/api/hand/control', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(canMessage)
                });
                
                if (!response.ok) {
                    const result = await response.json();
                    showMessage(`手指控制失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`手指控制失败: ${error.message}`, 'error');
            }
        }

        // 更新手指滑块的弹琴预设值，发送给后端的api/hand/fingers_piano_preset
        function updateFingersPianoPreset(deviceIndex) {
            // 取7个手指滑块的值
            const sliders = document.querySelectorAll(`#fingerSliders${deviceIndex} input[type="range"]`);
            const values = [];
            sliders.forEach(slider => {
                values.push(parseInt(slider.value));
            });
            // 发送到后端
            fetch('/api/hand/fingers_piano_preset', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(values)
            }).then(res => res.json()).then(data => {
                if (data.status === 'success') {
                    showMessage('手指弹琴预设值已更新');
                } else {
                    showMessage('手指弹琴预设值更新失败', 'error');
                }
            }).catch(err => {
                showMessage('手指弹琴预设值更新失败: ' + err, 'error');
            });
        }

        //这里应该是发送手指原子序列区域 /
        async function sendAtomicAction(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            const input = document.getElementById(`atomicInput${deviceIndex}`).value.trim();
            let sequenceArray;
            
            try {
                sequenceArray = JSON.parse(input);
                if (!Array.isArray(sequenceArray)) throw new Error("格式不对");
            } catch (e) {
                showMessage("输入格式错误", 'error');
                return;
            }
            
            const atomicData = {
                interface: config.canInterface,
                id: config.handType === 'left' ? 0x28 : 0x27,
                sequence: sequenceArray
            };
           
            try {
                const response = await fetch('/api/hand/atomic', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(atomicData)
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage('原子动作发送成功');
                } else {
                    showMessage(`原子动作发送失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`原子动作发送失败: ${error.message}`, 'error');
            }
        }

        // ===================== 机械臂控制相关 =====================
        // 渲染机械臂控制区
        function renderArmControl(deviceIndex, contentDiv) {
    contentDiv.innerHTML = `
        <div class="arm-control">
            <div class="arm-side-selection">
                <label>
                    <input type="radio" name="armSide${deviceIndex}" value="left" onchange="onArmSideChange(${deviceIndex})"> 左臂
                </label>
                <label>
                    <input type="radio" name="armSide${deviceIndex}" value="right" onchange="onArmSideChange(${deviceIndex})"> 右臂
                </label>
            </div>
            <div class="arm-basic-controls">
                <button class="btn btn-success" onclick="enableArm(${deviceIndex})">使能</button>
                <button class="btn btn-danger" onclick="disableArm(${deviceIndex})">失能</button>
                <button class="btn btn-danger" onclick="emergencyStop(${deviceIndex})">🛑 急停</button>
                <button class="btn btn-success" onclick="emergencyResume(${deviceIndex})">▶️ 恢复</button>
                <button class="btn" onclick="toZero(${deviceIndex})">回零</button>
                <button class="btn btn-set-to-zero" onclick="setToZero(${deviceIndex})">设置零点</button>
            </div>
            <div class="arm-mode-selection">
                <label>
                    <input type="radio" name="armMode${deviceIndex}" value="J" onchange="onArmModeChange(${deviceIndex})"> 关节模式(J)
                </label>
                <label>
                    <input type="radio" name="armMode${deviceIndex}" value="P" onchange="onArmModeChange(${deviceIndex})"> 位姿模式(P)
                </label>
            </div>
            <div id="armModeContent${deviceIndex}" class="arm-mode-content"></div>
    `;
}
function onArmSideChange(deviceIndex) {
    const side = document.querySelector(`input[name="armSide${deviceIndex}"]:checked`)?.value;
    canDeviceConfigs[deviceIndex].armSide = side;
}
function getArmSideLabel(deviceIndex) {
    const side = canDeviceConfigs[deviceIndex]?.armSide;
    return side === 'right' ? '右臂' : '左臂';
}
        // 选择机械臂模式后渲染对应内容
        function onArmModeChange(deviceIndex) {
            const armMode = document.querySelector(`input[name="armMode${deviceIndex}"]:checked`)?.value;
            const armModeContentDiv = document.getElementById(`armModeContent${deviceIndex}`);
            
            if (!armMode) {
                armModeContentDiv.innerHTML = '';
                return;
            }

            canDeviceConfigs[deviceIndex].armMode = armMode;
            
            if (armMode === 'J') {
                renderJointControl(deviceIndex, armModeContentDiv);
            } else if (armMode === 'P') {
                renderPoseControl(deviceIndex, armModeContentDiv);
            }
        }

        // 渲染关节控制区
        function renderJointControl(deviceIndex, contentDiv) {
            contentDiv.innerHTML = `
                <div class="joint-control">
                    <h4>关节控制</h4>
                    <div class="joint-inputs">
                        ${[1,2,3,4,5,6].map(i => `
                            <div class="form-group">
                                <label>J${i} 角度 (°): <span class="range-value" id="j${i}Value${deviceIndex}">0.000</span></label>
                                <input type="number" id="j${i}Input${deviceIndex}" value="0" step="0.001" 
                                       onchange="updateJointFromInput(${deviceIndex}, ${i})">
                                <div class="range-container">
                                    <input type="range" id="j${i}Range${deviceIndex}" 
                                           min="${getJointMin(i)}" max="${getJointMax(i)}" value="0" step="1" 
                                           oninput="updateJointFromSlider(${deviceIndex}, ${i})">
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="form-group">
                        <label>运动速度 (%):</label>
                        <input type="number" id="speedInput${deviceIndex}" value="50" min="0" max="100" 
                               onchange="updateSpeedFromInput(${deviceIndex})">
                        <div class="range-container">
                            <input type="range" id="speedRange${deviceIndex}" min="0" max="100" value="50" 
                                   oninput="updateSpeedFromSlider(${deviceIndex})">
                            <span class="range-value" id="speedValue${deviceIndex}">50</span>
                        </div>
                    </div>
                </div>
            `;
        }
        // 渲染位姿控制区
        function renderPoseControl(deviceIndex, contentDiv) {
    contentDiv.innerHTML = `
        <div class="pose-control">
            <h4>位姿控制</h4>
            <div class="pose-inputs">
                <div class="form-group">
                    <label>X 坐标 (mm): <span class="range-value" id="poseXValue${deviceIndex}">400.000</span></label>
                    <input type="number" id="poseXInput${deviceIndex}" value="400" min="300" max="500" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'X')">
                    <div class="range-container">
                        <input type="range" id="poseXRange${deviceIndex}" min="300000" max="500000" value="400000" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'X')">
                    </div>
                </div>
                <div class="form-group">
                    <label>Y 坐标 (mm): <span class="range-value" id="poseYValue${deviceIndex}">0.000</span></label>
                    <input type="number" id="poseYInput${deviceIndex}" value="0" min="-150" max="150" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'Y')">
                    <div class="range-container">
                        <input type="range" id="poseYRange${deviceIndex}" min="-150000" max="150000" value="0" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'Y')">
                    </div>
                </div>
                <div class="form-group">
                    <label>Z 坐标 (mm): <span class="range-value" id="poseZValue${deviceIndex}">170.000</span></label>
                    <input type="number" id="poseZInput${deviceIndex}" value="170" min="100" max="300" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'Z')">
                    <div class="range-container">
                        <input type="range" id="poseZRange${deviceIndex}" min="100000" max="300000" value="170000" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'Z')">
                    </div>
                </div>
                <div class="form-group">
                    <label>RX (°): <span class="range-value" id="poseRXValue${deviceIndex}">0.000</span></label>
                    <input type="number" id="poseRXInput${deviceIndex}" value="0" min="-180" max="180" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'RX')">
                    <div class="range-container">
                        <input type="range" id="poseRXRange${deviceIndex}" min="-180000" max="180000" value="0" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'RX')">
                    </div>
                </div>
                <div class="form-group">
                    <label>RY (°): <span class="range-value" id="poseRYValue${deviceIndex}">80.000</span></label>
                    <input type="number" id="poseRYInput${deviceIndex}" value="80" min="70" max="90" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'RY')">
                    <div class="range-container">
                        <input type="range" id="poseRYRange${deviceIndex}" min="70000" max="90000" value="80000" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'RY')">
                    </div>
                </div>
                <div class="form-group">
                    <label>RZ (°): <span class="range-value" id="poseRZValue${deviceIndex}">0.000</span></label>
                    <input type="number" id="poseRZInput${deviceIndex}" value="0" min="-180" max="180" step="1" onchange="updatePoseFromInput(${deviceIndex}, 'RZ')">
                    <div class="range-container">
                        <input type="range" id="poseRZRange${deviceIndex}" min="-180000" max="180000" value="0" step="100" oninput="updatePoseFromSlider(${deviceIndex}, 'RZ')">
                    </div>
                </div>
                <div class="form-group">
                    <label>运动速度 (%):</label>
                    <input type="number" id="poseSpeedInput${deviceIndex}" value="50" min="0" max="100" step="1" onchange="updatePoseSpeedFromInput(${deviceIndex})">
                    <div class="range-container">
                        <input type="range" id="poseSpeedRange${deviceIndex}" min="0" max="100" value="50" step="1" oninput="updatePoseSpeedFromSlider(${deviceIndex})">
                        <span class="range-value" id="poseSpeedValue${deviceIndex}">50</span>
                    </div>
                </div>
                <!-- <button class="btn btn-success" onclick="sendPoseCommand(${deviceIndex})">发送位姿</button> -->
            </div>
        </div>
           <button onclick="updateArmPianoPreset(${deviceIndex})">更新${getArmSideLabel(deviceIndex)}弹琴预设值</button>

    `;
}
        
        // 更新手臂弹琴位姿预设值，发送的是位姿的值
        function updateArmPianoPreset(deviceIndex) {
        const config = canDeviceConfigs[deviceIndex];
        if (!config) return;
        // 取P模式下6个滑块的值
        const axes = ['X', 'Y', 'Z', 'RX', 'RY', 'RZ'];
        const values = axes.map(axis => parseInt(document.getElementById(`pose${axis}Range${deviceIndex}`)?.value || 0));
        fetch('/api/arm/arm_piano_preset', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ side: config.armSide, values: values })
        }).then(res => res.json()).then(data => {
            if (data.status === 'success') {
                showMessage(`${getArmSideLabel(deviceIndex)}弹琴预设值已更新`);
            } else {
                showMessage(`${getArmSideLabel(deviceIndex)}弹琴预设值更新失败`, 'error');
            }
        }).catch(err => {
            showMessage(`${getArmSideLabel(deviceIndex)}弹琴预设值更新失败: ` + err, 'error');
        });
    }

        // 这里应该是发送机械臂原子序列区域
        // function renderPoseControl(deviceIndex, contentDiv) {
        //     contentDiv.innerHTML = `


        //         <div class="pose-control">
        //             <h4>位姿控制</h4>
        //             <div class="pose-inputs">
        //                 <div class="form-group">
        //                     <label>Y序列批量运动:</label>
        //                     <textarea id="ySequenceInput${deviceIndex}" rows="3" style="width:100%;">[[0,1],[20,0.5],[70,1]]</textarea>
        //                     <button class="btn btn-success" onclick="sendYSequence(${deviceIndex})">发送Y序列</button>
        //                 </div>
        //             </div>
        //         </div>
        //     `;
        // }

        // 关节角度范围
        function getJointMin(jointIndex) {
            const mins = [-154000, 0, -175000, -102000, -75000, -120000];
            return mins[jointIndex - 1];
        }

        function getJointMax(jointIndex) {
            const maxs = [154000, 195000, 0, 102000, 75000, 120000];
            return maxs[jointIndex - 1];
        }

        // 关节输入与滑块联动
        function updateJointFromInput(deviceIndex, jointIndex) {
            const input = document.getElementById(`j${jointIndex}Input${deviceIndex}`);
            const slider = document.getElementById(`j${jointIndex}Range${deviceIndex}`);
            const valueDisplay = document.getElementById(`j${jointIndex}Value${deviceIndex}`);
            
            const value = parseFloat(input.value) * 1000;
            slider.value = value;
            valueDisplay.textContent = input.value;
            
            sendJointCommand(deviceIndex);
        }

        function updateJointFromSlider(deviceIndex, jointIndex) {
            const slider = document.getElementById(`j${jointIndex}Range${deviceIndex}`);
            const input = document.getElementById(`j${jointIndex}Input${deviceIndex}`);
            const valueDisplay = document.getElementById(`j${jointIndex}Value${deviceIndex}`);
            
            const value = (parseInt(slider.value) / 1000);
            input.value = value.toFixed(3);
            valueDisplay.textContent = value.toFixed(3);
            
            sendJointCommand(deviceIndex);
        }

        // 速度输入与滑块联动
        function updateSpeedFromInput(deviceIndex) {
            const input = document.getElementById(`speedInput${deviceIndex}`);
            const slider = document.getElementById(`speedRange${deviceIndex}`);
            const valueDisplay = document.getElementById(`speedValue${deviceIndex}`);
            
            slider.value = input.value;
            valueDisplay.textContent = input.value;
        }
        // 关节速度输入与滑块联动
        function updateSpeedFromSlider(deviceIndex) {
            const slider = document.getElementById(`speedRange${deviceIndex}`);
            const input = document.getElementById(`speedInput${deviceIndex}`);
            const valueDisplay = document.getElementById(`speedValue${deviceIndex}`);
            
            input.value = slider.value;
            valueDisplay.textContent = slider.value;
        }

        // 关节指令防抖并发送
        let jointCommandTimeouts = {};
        async function sendJointCommand(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            if (jointCommandTimeouts[deviceIndex]) {
                clearTimeout(jointCommandTimeouts[deviceIndex]);
            }
            
            jointCommandTimeouts[deviceIndex] = setTimeout(async () => {
                const jointData = {
                    interface: config.canInterface,
                    j1: parseInt(document.getElementById(`j1Range${deviceIndex}`)?.value || 0),
                    j2: parseInt(document.getElementById(`j2Range${deviceIndex}`)?.value || 0),
                    j3: parseInt(document.getElementById(`j3Range${deviceIndex}`)?.value || 0),
                    j4: parseInt(document.getElementById(`j4Range${deviceIndex}`)?.value || 0),
                    j5: parseInt(document.getElementById(`j5Range${deviceIndex}`)?.value || 0),
                    j6: parseInt(document.getElementById(`j6Range${deviceIndex}`)?.value || 0),
                    speed: parseInt(document.getElementById(`speedRange${deviceIndex}`)?.value || 50)
                };
                
                try {
                    const response = await fetch('/api/arm/send_joint', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(jointData)
                    });
                    
                    if (!response.ok) {
                        const result = await response.json();
                        showMessage(`关节控制失败: ${result.error}`, 'error');
                    }
                } catch (error) {
                    showMessage(`关节控制失败: ${error.message}`, 'error');
                }
            }, 100);
        }

                // 滑块与输入框联动
        function updatePoseFromInput(deviceIndex, axis) {
            const input = document.getElementById(`pose${axis}Input${deviceIndex}`);
            const range = document.getElementById(`pose${axis}Range${deviceIndex}`);
            const valueDisplay = document.getElementById(`pose${axis}Value${deviceIndex}`);
            let value = parseFloat(input.value);
            if (axis === 'X' || axis === 'Y' || axis === 'Z') value = value * 1000;
            range.value = value;
            valueDisplay.textContent = (value / 1000).toFixed(3);
            sendPoseCommand(deviceIndex);
        }
        // 位姿输入与滑块联动
        function updatePoseFromSlider(deviceIndex, axis) {
            const range = document.getElementById(`pose${axis}Range${deviceIndex}`);
            const input = document.getElementById(`pose${axis}Input${deviceIndex}`);
            const valueDisplay = document.getElementById(`pose${axis}Value${deviceIndex}`);
            let value = parseInt(range.value);
            input.value = (value / 1000).toFixed(3);
            valueDisplay.textContent = (value / 1000).toFixed(3);
            sendPoseCommand(deviceIndex);
        }
        // 位姿速度输入与滑块联动
        function updatePoseSpeedFromInput(deviceIndex) {
            const input = document.getElementById(`poseSpeedInput${deviceIndex}`);
            const range = document.getElementById(`poseSpeedRange${deviceIndex}`);
            const valueDisplay = document.getElementById(`poseSpeedValue${deviceIndex}`);
            range.value = input.value;
            valueDisplay.textContent = input.value;
        }
        // 位姿速度输入与滑块联动
        function updatePoseSpeedFromSlider(deviceIndex) {
            const range = document.getElementById(`poseSpeedRange${deviceIndex}`);
            const input = document.getElementById(`poseSpeedInput${deviceIndex}`);
            const valueDisplay = document.getElementById(`poseSpeedValue${deviceIndex}`);
            input.value = range.value;
            valueDisplay.textContent = range.value;
        }

        // 发送位姿指令
        async function sendPoseCommand(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            // 取值并转为0.001单位
            const poseData = {
                interface: config.canInterface,
                x: parseInt(document.getElementById(`poseXRange${deviceIndex}`).value),
                y: parseInt(document.getElementById(`poseYRange${deviceIndex}`).value),
                z: parseInt(document.getElementById(`poseZRange${deviceIndex}`).value),
                rx: parseInt(document.getElementById(`poseRXRange${deviceIndex}`).value),
                ry: parseInt(document.getElementById(`poseRYRange${deviceIndex}`).value),
                rz: parseInt(document.getElementById(`poseRZRange${deviceIndex}`).value),
                speed: parseInt(document.getElementById(`poseSpeedRange${deviceIndex}`).value)
            };
            try {
                const response = await fetch('/api/arm/send_pose', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(poseData)
                });
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 位姿指令发送成功`);
                } else {
                    showMessage(`${config.canInterface} 位姿指令发送失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`位姿指令发送失败: ${error.message}`, 'error');
            }
        }
        // 机械臂基础操作
        // 使能机械臂
        async function enableArm(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/enable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂使能成功`);
                } else {
                    showMessage(`${config.canInterface} 机械臂使能失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂使能失败: ${error.message}`, 'error');
            }
        }
        // 失能机械臂
        async function disableArm(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/disable', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂失能成功`);
                } else {
                    showMessage(`${config.canInterface} 机械臂失能失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂失能失败: ${error.message}`, 'error');
            }
        }
        // 急停机械臂
        async function emergencyStop(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/emergency_stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂急停成功`, 'error');
                } else {
                    showMessage(`${config.canInterface} 机械臂急停失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂急停失败: ${error.message}`, 'error');
            }
        }

        async function emergencyResume(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/emergency_resume', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂恢复成功`);
                } else {
                    showMessage(`${config.canInterface} 机械臂恢复失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂恢复失败: ${error.message}`, 'error');
            }
        }
        // 回零机械臂
        async function toZero(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/to_zero', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂回零成功`);
                } else {
                    showMessage(`${config.canInterface} 机械臂回零失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂回零失败: ${error.message}`, 'error');
            }
        }
        // 设置机械臂关节的零点位置，需要改一下，当前是设置一个关节的零点位置，需要设置所有关节的零点位置
        async function setToZero(deviceIndex) {
            //deviceIndex是机械臂的索引，从0开始
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            try {
                const response = await fetch('/api/arm/set_zero', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: config.canInterface })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} 机械臂设置零点成功`);
                } else {
                    showMessage(`${config.canInterface} 机械臂设置零点失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`机械臂设置零点失败: ${error.message}`, 'error');
            }
        }

        // 发送Y序列批量运动
        async function sendYSequence(deviceIndex) {
            const config = canDeviceConfigs[deviceIndex];
            if (!config) return;
            
            let input = document.getElementById(`ySequenceInput${deviceIndex}`).value;
            let seq;
            try {
                seq = JSON.parse(input);
                if (!Array.isArray(seq)) throw new Error();
            } catch {
                showMessage('Y序列输入格式错误', 'error');
                return;
            }
            
            let sendSeq = [];
            for (const [y, t] of seq) {
                if (typeof y !== 'number' || typeof t !== 'number' || y < -70 || y > 70) {
                    showMessage('Y坐标超范围或格式错误', 'error');
                    return;
                }
                sendSeq.push([Math.round(y * 1000), t * 1000]);
            }
            
            try {
                const response = await fetch('/api/arm/y_sequence', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        interface: config.canInterface,
                        sequence: sendSeq 
                    })
                });
                
                const result = await response.json();
                if (response.ok) {
                    showMessage(`${config.canInterface} Y序列发送成功`);
                } else {
                    showMessage(`${config.canInterface} Y序列发送失败: ${result.error}`, 'error');
                }
            } catch (error) {
                showMessage(`Y序列发送失败: ${error.message}`, 'error');
            }
        }
    </script>
   </body>
   </html>