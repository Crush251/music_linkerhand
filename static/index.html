<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¹ é’¢ç´æ¼”å¥æ§åˆ¶ç³»ç»Ÿ</title>
   <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="container">
        <h1>ğŸ¹ é’¢ç´æ¼”å¥æ§åˆ¶ç³»ç»Ÿ</h1>
        <h2>ğŸ¤– æœºæ¢°è‡‚æ§åˆ¶</h2>
        <div class="status-bar" id="statusBar">
            ç³»ç»ŸçŠ¶æ€: æœªè¿æ¥
        </div>

        <div id="messageArea"></div>
        <!-- è¿æ¥æ§åˆ¶ -->
        <div class="control-section">
            <h3>ğŸ”Œ è¿æ¥æ§åˆ¶</h3>
            <div class="connection-info">
                <strong>CANæ¥å£:</strong>
                <div class="interface-list" id="interfaceList">
                    <span>æœªæ£€æµ‹åˆ°æ¥å£</span>
                </div>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center;">
                <button class="btn btn-success" onclick="enableSystem()">ä½¿èƒ½ç³»ç»Ÿ</button>
                <button class="btn btn-danger" onclick="disableSystem()">å¤±èƒ½ç³»ç»Ÿ</button>
                <button class="btn" onclick="refreshInterfaces()">åˆ·æ–°æ¥å£</button>
                <button class="btn" onclick="toZero()">å›é›¶</button>
          
                <button class="btn btn-danger" onclick="emergencyStop()">ğŸ›‘ æ€¥åœ</button>
                <button class="btn btn-success" onclick="emergencyResume()">â–¶ï¸ æ¢å¤</button>
                
                <button class="btn btn-set-to-zero " onclick="setToZero()">è®¾ç½®é›¶ç‚¹</button>
            </div>
        </div>
        <div class="control-section">
            <h3>ğŸ“ Yåºåˆ—æ‰¹é‡è¿åŠ¨</h3>
            <div class="form-group">
                <label>è¾“å…¥Yåºåˆ—ï¼ˆæ ¼å¼å¦‚[[0,1],[20,0.5],[70,1]]ï¼ŒYå•ä½ä¸ºåº¦ï¼ŒèŒƒå›´-70~70ï¼Œæ—¶é—´å•ä½sï¼‰:</label>
                <textarea id="ySequenceInput" rows="3" style="width:100%;"></textarea>
            </div>
            <button class="btn btn-success" onclick="sendYSequence()">å‘é€Yåºåˆ—</button>
        </div>
         <!-- å…³èŠ‚æ§åˆ¶ -->
        <div class="control-section">
            <h2>ğŸ¦¾ å…³èŠ‚æ§åˆ¶ (0x155/156/157)</h2>
            <div class="joint-inputs">
                <div class="form-group">
                    <label>J1 è§’åº¦ (Â°): <span class="range-value" id="j1Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j1" min="-154000" max="154000" value="0" step="1" oninput="handleJointChange('j1')">
                    </div>
                </div>
                <div class="form-group">
                    <label>J2 è§’åº¦ (Â°): <span class="range-value" id="j2Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j2" min="0" max="195000" value="0" step="1" oninput="handleJointChange('j2')">
                    </div>
                </div>
                <div class="form-group">
                    <label>J3 è§’åº¦ (Â°): <span class="range-value" id="j3Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j3" min="-175000" max="0" value="0" step="1" oninput="handleJointChange('j3')">
                    </div>
                </div>
                <div class="form-group">
                    <label>J4 è§’åº¦ (Â°): <span class="range-value" id="j4Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j4" min="-102000" max="102000" value="0" step="1" oninput="handleJointChange('j4')">
                    </div>
                </div>
                <div class="form-group">
                    <label>J5 è§’åº¦ (Â°): <span class="range-value" id="j5Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j5" min="-75000" max="75000" value="0" step="1" oninput="handleJointChange('j5')">
                    </div>
                </div>
                <div class="form-group">
                    <label>J6 è§’åº¦ (Â°): <span class="range-value" id="j6Value">0.000</span></label>
                    <div class="range-container">
                        <input type="range" id="j6" min="-120000" max="120000" value="0" step="1" oninput="handleJointChange('j6')">
                    </div>
                </div>
            </div>
            <div class="form-group">
                <label>è¿åŠ¨é€Ÿåº¦ (%):</label>
                <div class="range-container">
                    <input type="range" id="speedRange" min="0" max="100" value="50" oninput="updateSpeedValue()">
                    <span class="range-value" id="speedValue">50</span>
                </div>
            </div>
        </div>

    </div>
<div class="container">
    <h2>æ‰‹æŒ‡æ§åˆ¶</h2>
    <div>
        <h3>åŸå­æ“ä½œå°æŒ‡4,æ— åæŒ‡3,ä¸­æŒ‡2,é£ŸæŒ‡1,å¤§æ‹‡æŒ‡0</h3>
        <label>åŸå­æ“ä½œè¾“å…¥ï¼ˆå¦‚ [
            [[1,4],[0.1,1]],
            [[1,4,2],[0.1,0.3,0.5]],
            [[1],[0.2]],
            [[1],[0.2]]
          ]ï¼‰:</label><br>
        <input type="text" id="pressInput" style="width: 400px;" value="[
        [[1,4],[0.1,1]],
        [[1,4,2],[0.1,0.3,0.5]],
        [[1],[0.2]],
        [[1],[0.2]]
      ]
      ">
        <button onclick="applyAtomicPress()">å‘é€åŸå­åŠ¨ä½œ</button>
    </div>
    
</div>
<div class="container">
    <h2>æ··åˆæ§åˆ¶ï¼ˆæ‰‹+æœºæ¢°è‡‚ï¼‰</h2>
    <div>
        <label>æ··åˆè¾“å…¥ï¼ˆå¦‚ [
            [["can0"],[1,4],[0.1,0.2]],
            [["can1"],[1,3],[0.2,0.5]],
            [["can2"],[20,1]],
            [["can3"],[70,1]]
        ] ï¼‰:</label><br>
        <textarea id="mixedInput" style="width: 100%; height: 120px;">[
    [["can0"],[1,4],[0.1,0.2]],
    [["can1"],[1,3],[0.2,0.5]],
    [["can2"],[20,1]],
    [["can3"],[70,1]]
]</textarea>
        <button class="btn btn-success" onclick="handleMixedInput()">å‘é€æ··åˆæŒ‡ä»¤</button>
    </div>
</div>
    <script>
        //æ‰‹æŒ‡æ§åˆ¶
function applyAtomicPress() {
            const input = document.getElementById("pressInput").value.trim();
            let sequenceArray;
            try {
                sequenceArray = JSON.parse(input);
                if (!Array.isArray(sequenceArray) || !Array.isArray(sequenceArray[0])) {
                    throw new Error("æ ¼å¼ä¸å¯¹");
                }
            } catch (e) {
                alert("è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ï¼š[[[1,4],[0.1,1]],[[1],[0.2]]]");
                return;
            }
            enqueueAtomicSequence(sequenceArray);
        }

        const currentState = [0x01,0, 240, 240, 240, 240, 240, 110];
        const activeTimers = {};  // æ¯æ ¹æ‰‹æŒ‡çš„å®šæ—¶å™¨
        const atomicQueue = [];
        let isProcessing = false;

        function sendCANState() {
            const canMessage = {
                interface: "can0",
                id: 0x28,
                data: currentState
            };
            fetch('/api/hand/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(canMessage)
            });
        }

        function enqueueAtomicSequence(sequenceArray) {
            atomicQueue.push(...sequenceArray);
            if (!isProcessing) {
                processNextSequence();
            }
        }

        function processNextSequence() {
            if (atomicQueue.length === 0) {
                isProcessing = false;
                return;
            }

            isProcessing = true;
            const [fingers, durations] = atomicQueue.shift();

            // è®¾ç½®æ¯ä¸ªæ‰‹æŒ‡ä¸º"æŒ‰ä¸‹"çŠ¶æ€ï¼ˆå€¼200ï¼‰
            fingers.forEach(fid => {
                const index = fid + 2;
                currentState[index] = 200;
            });
            sendCANState();

            // ä¸ºæ¯ä¸ªæ‰‹æŒ‡è®¾ç½®"æŠ¬èµ·"å®šæ—¶å™¨
            fingers.forEach((fid, i) => {
                const duration = durations[i] * 1000;
                const index = fid + 2;

                // å–æ¶ˆæ—§å®šæ—¶å™¨ï¼ˆå¦‚æœè¿™ä¸ªæ‰‹æŒ‡æœ‰å®šæ—¶ä»»åŠ¡ï¼‰
                if (activeTimers[index]) {
                    clearTimeout(activeTimers[index]);
                }

                activeTimers[index] = setTimeout(() => {
                    currentState[index] = 240; // æŠ¬èµ·
                    sendCANState();
                    delete activeTimers[index];
                }, duration);
            });

            // ä¸‹ä¸€ä¸ªåºåˆ—
            setTimeout(() => {
                processNextSequence();
            }, Math.max(...durations) * 1000 + 50);
        }


        async function handleMultiActionInput() {
            const input = document.getElementById('multiAtomInput').value.trim();

            try {
                // å®‰å…¨è§£æè¾“å…¥
                const parsed = Function('"use strict";return (' + input + ')')();
                const [fingersList, timesList] = parsed;

                if (!Array.isArray(fingersList) || !Array.isArray(timesList) || fingersList.length !== timesList.length) {
                    alert("æ ¼å¼é”™è¯¯ï¼Œä¾‹ï¼š{[[1,4],[2]], [[0.1,0.2],[0.3]]}");
                    return;
                }

                for (let i = 0; i < fingersList.length; i++) {
                    const fingers = fingersList[i];
                    const times = timesList[i];

                    if (fingers.length !== times.length) {
                        alert(`ç¬¬ ${i + 1} ç»„æ‰‹æŒ‡æ•°ä¸æ—¶é—´æ•°ä¸ä¸€è‡´`);
                        return;
                    }

                    // åŒæ—¶å‘é€è¿™ä¸€ç»„æ‰€æœ‰æ‰‹æŒ‡çš„"æŒ‰ä¸‹"å‘½ä»¤
                    for (let j = 0; j < fingers.length; j++) {
                        const fid = fingers[j];
                        sendCustomAction([...atomActions[fid]]);
                    }

                    // è®¾ç½®æŠ¬èµ·å®šæ—¶å™¨
                    for (let j = 0; j < fingers.length; j++) {
                        const fid = fingers[j];
                        const delay = times[j] * 1000;
                        setTimeout(() => {
                            const release = [...releaseAction];
                            if (fid !== 0) release[fid + 1] = 240;
                            sendCustomAction(release);
                        }, delay);
                    }

                    // ç­‰å¾…è¿™ä¸€ç»„æœ€é•¿æ—¶é—´å†è¿›å…¥ä¸‹ä¸€ç»„
                    const maxDelay = Math.max(...times) * 1000;
                    await new Promise(resolve => setTimeout(resolve, maxDelay + 50));
                }

            } catch (err) {
                alert("è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ ¼å¼ï¼Œä¾‹ï¼š{[[1,4],[2]], [[0.1,0.2],[0.3]]}");
            }
        }

        //æœºæ¢°è‡‚æ§åˆ¶
        let systemEnabled = true;
        let canInterfaces = [];

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            refreshInterfaces();
        });

        // æ›´æ–°é€Ÿåº¦æ˜¾ç¤ºå€¼
        function updateSpeedValue() {
            const speedRange = document.getElementById('speedRange');
            const speedValue = document.getElementById('speedValue');
            speedValue.textContent = speedRange.value;
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, type = 'success') {
            const messageArea = document.getElementById('messageArea');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            messageArea.appendChild(messageDiv);
            
            // 1ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
            setTimeout(() => {
                messageDiv.remove();
            }, 1000);
        }

        // æ›´æ–°çŠ¶æ€æ 
        function updateStatusBar(status, color = '#4ecdc4') {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = `ç³»ç»ŸçŠ¶æ€: ${status}`;
            statusBar.style.background = `linear-gradient(45deg, ${color}, #764ba2)`;
        }
        
        // å‘é€Yåºåˆ—
        async function sendYSequence() {
            if (!systemEnabled) {
                showMessage('è¯·å…ˆä½¿èƒ½ç³»ç»Ÿ', 'error');
                return;
            }
            let input = document.getElementById('ySequenceInput').value;
            let seq;
            try {
                seq = JSON.parse(input);
                if (!Array.isArray(seq)) throw new Error();
            } catch {
                showMessage('è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œéœ€ä¸º[[y, t], ...]çš„JSONæ•°ç»„', 'error');
                return;
            }
            // æ ¡éªŒèŒƒå›´å¹¶è½¬æ¢
            let sendSeq = [];
            for (const [y, t] of seq) {
                if (typeof y !== 'number' || typeof t !== 'number' || y < -70 || y > 70) {
                    showMessage('Yåæ ‡è¶…èŒƒå›´æˆ–æ ¼å¼é”™è¯¯', 'error');
                    return;
                }
                sendSeq.push([Math.round(y * 1000), t*1000]);
            }
            try {
                const response = await fetch('/api/arm/y_sequence', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({sequence: sendSeq})
                });
                const data = await response.json();
                if (response.ok) {
                    showMessage('Yåºåˆ—å·²å‘é€');
                } else {
                    showMessage('å‘é€å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }
        // åˆ·æ–°CANæ¥å£
        
        async function refreshInterfaces() {
            try {
                const response = await fetch('/api/can_interfaces');
                const data = await response.json();
                canInterfaces = data.interfaces || [];
                
                const interfaceList = document.getElementById('interfaceList');
                if (canInterfaces.length > 0) {
                    interfaceList.innerHTML = canInterfaces.map(iface => 
                        `<span class="interface-tag">${iface}</span>`
                    ).join('');
                } else {
                    interfaceList.innerHTML = '<span>æœªæ£€æµ‹åˆ°æ¥å£</span>';
                }
            } catch (error) {
                showMessage('è·å–CANæ¥å£å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ä½¿èƒ½ç³»ç»Ÿ
        async function enableSystem() {
            try {
                const response = await fetch('/api/arm/enable', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (response.ok) {
                    systemEnabled = true;
                    updateStatusBar('å·²ä½¿èƒ½', '#44bd32');
                    showMessage('ç³»ç»Ÿä½¿èƒ½æˆåŠŸ');
                } else {
                    showMessage('ç³»ç»Ÿä½¿èƒ½å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('ç³»ç»Ÿä½¿èƒ½å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å¤±èƒ½ç³»ç»Ÿ
        async function disableSystem() {
            try {
                const response = await fetch('/api/arm/disable', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                if (response.ok) {
                    systemEnabled = false;
                    updateStatusBar('å·²å¤±èƒ½', '#ff6b6b');
                    showMessage('ç³»ç»Ÿå¤±èƒ½æˆåŠŸ');
                } else {
                    showMessage('ç³»ç»Ÿå¤±èƒ½å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('ç³»ç»Ÿå¤±èƒ½å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å›é›¶
        async function toZero() {
            try {
                const response = await fetch('/api/arm/to_zero', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    showMessage('å›é›¶æˆåŠŸ');
                } else {
                    showMessage('å›é›¶å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('å›é›¶å¤±è´¥: ' + error.message, 'error');
            }
        }
        
        // å‘é€æ§åˆ¶æŒ‡ä»¤ (0x151)
        async function sendControlCommand() {
            if (!systemEnabled) {
                showMessage('è¯·å…ˆä½¿èƒ½ç³»ç»Ÿ', 'error');
                return;
            }

            const moveMode = document.querySelector('input[name="moveMode"]:checked');
            const speed = document.getElementById('speedRange').value;

            if (!moveMode) {
                showMessage('è¯·é€‰æ‹©MOVEæ¨¡å¼', 'error');
                return;
            }

            try {
                const response = await fetch('/api/arm/send_control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        move_mode: moveMode.value,
                        speed: parseInt(speed)
                    })
                });

                const data = await response.json();
                if (response.ok) {
                    showMessage(`æ§åˆ¶æŒ‡ä»¤å‘é€æˆåŠŸ - æ¨¡å¼: ${moveMode.value}, é€Ÿåº¦: ${speed}%`);
                } else {
                    showMessage('æ§åˆ¶æŒ‡ä»¤å‘é€å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('æ§åˆ¶æŒ‡ä»¤å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }

        // å¤„ç†å…³èŠ‚å€¼å˜åŒ–
        let jointChangeTimeout;
        function handleJointChange(jointId) {
            const slider = document.getElementById(jointId);
            const valueDisplay = document.getElementById(jointId + 'Value');
            const value = parseInt(slider.value);
            valueDisplay.textContent = (value / 1000).toFixed(3);

            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (jointChangeTimeout) {
                clearTimeout(jointChangeTimeout);
            }

            // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œå»¶è¿Ÿ100mså‘é€æŒ‡ä»¤
            jointChangeTimeout = setTimeout(() => {
                sendJointCommand();
            }, 100);
        }

        // å‘é€å…³èŠ‚æŒ‡ä»¤
        async function sendJointCommand() {
            if (!systemEnabled) {
                showMessage('è¯·å…ˆä½¿èƒ½ç³»ç»Ÿ', 'error');
                return;
            }

            const jointData = {
                j1: parseInt(document.getElementById('j1').value),
                j2: parseInt(document.getElementById('j2').value),
                j3: parseInt(document.getElementById('j3').value),
                j4: parseInt(document.getElementById('j4').value),
                j5: parseInt(document.getElementById('j5').value),
                j6: parseInt(document.getElementById('j6').value),
                speed: parseInt(document.getElementById('speedRange').value)
            };

            try {
                const response = await fetch('/api/arm/send_joint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(jointData)
                });

                const data = await response.json();
                if (!response.ok) {
                    showMessage('å…³èŠ‚æŒ‡ä»¤å‘é€å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('å…³èŠ‚æŒ‡ä»¤å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }


        // æ€¥åœ
        async function emergencyStop() {
            try {
                const response = await fetch('/api/arm/emergency_stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    updateStatusBar('æ€¥åœçŠ¶æ€', '#ff6b6b');
                    showMessage('æ€¥åœæ‰§è¡ŒæˆåŠŸ', 'error');
                } else {
                    showMessage('æ€¥åœæ‰§è¡Œå¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('æ€¥åœæ‰§è¡Œå¤±è´¥: ' + error.message, 'error');
            }
        }
      
        // æ€¥åœæ¢å¤
        async function emergencyResume() {
            try {
                const response = await fetch('/api/arm/emergency_resume', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    updateStatusBar('æ€¥åœæ¢å¤', '#feca57');
                    showMessage('æ€¥åœæ¢å¤æˆåŠŸï¼Œè¯·é‡æ–°ä½¿èƒ½ç³»ç»Ÿ', 'success');
                } else {
                    showMessage('æ€¥åœæ¢å¤å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('æ€¥åœæ¢å¤å¤±è´¥: ' + error.message, 'error');
            }
        }


        // å®šæœŸæ£€æŸ¥ç³»ç»ŸçŠ¶æ€
        setInterval(refreshInterfaces, 30000); // æ¯30ç§’åˆ·æ–°ä¸€æ¬¡æ¥å£åˆ—è¡¨

        // ========== æ··åˆè¾“å…¥å¤„ç† ==========
        // ç‹¬ç«‹é˜Ÿåˆ—å’ŒçŠ¶æ€ï¼Œç¡®ä¿can0/can1/can2/can3äº’ä¸å¹²æ‰°
        const handQueues = { can0: [], can1: [] };
        const handProcessing = { can0: false, can1: false };
        const handStates = {
            can0: [0x01,0, 240, 240, 240, 240, 240, 110],
            can1: [0x01,0, 240, 240, 240, 240, 240, 110]
        };
        const handTimers = { can0: {}, can1: {} };

        const armQueues = { can2: [], can3: [] };
        const armProcessing = { can2: false, can3: false };

        function handleMixedInput() {
            const input = document.getElementById("mixedInput").value.trim();
            let sequenceArray;
            try {
                sequenceArray = JSON.parse(input);
                if (!Array.isArray(sequenceArray)) throw new Error("æ ¼å¼ä¸å¯¹");
            } catch (e) {
                alert("è¾“å…¥æ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥ï¼");
                return;
            }
            // åˆ†ç±»
            for (const item of sequenceArray) {
                if (!Array.isArray(item) || item.length < 2) continue;
                const can = item[0][0];
                if (can === "can0" || can === "can1") {
                    handQueues[can].push(item);
                    if (!handProcessing[can]) processHandQueue(can);
                } else if (can === "can2" || can === "can3") {
                    armQueues[can].push(item);
                    if (!armProcessing[can]) processArmQueue(can);
                }
            }
        }
        // æ‰‹æŒ‡åŠ¨ä½œå¤„ç†
        function processHandQueue(can) {
            if (handQueues[can].length === 0) {
                handProcessing[can] = false;
                return;
            }
            handProcessing[can] = true;
            const item = handQueues[can].shift();
            const fingers = item[1];
            const durations = item[2];
            // è®¾ç½®æ¯ä¸ªæ‰‹æŒ‡ä¸º"æŒ‰ä¸‹"çŠ¶æ€ï¼ˆå€¼200ï¼‰
            fingers.forEach(fid => {
                const index = fid + 2;
                handStates[can][index] = 200;
            });
            sendCANStateWithCan(can);
            // ä¸ºæ¯ä¸ªæ‰‹æŒ‡è®¾ç½®"æŠ¬èµ·"å®šæ—¶å™¨
            fingers.forEach((fid, i) => {
                const duration = durations[i] * 1000;
                const index = fid + 2;
                if (handTimers[can][index]) clearTimeout(handTimers[can][index]);
                handTimers[can][index] = setTimeout(() => {
                    handStates[can][index] = 240;
                    sendCANStateWithCan(can);
                    delete handTimers[can][index];
                }, duration);
            });
            setTimeout(() => {
                processHandQueue(can);
            }, Math.max(...durations) * 1000 + 50);
        }
        function sendCANStateWithCan(can) {
            const canMessage = {
                interface: can,
                id: 0x28,
                data: handStates[can]
            };
            fetch('/api/hand/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(canMessage)
            });
        }
        // æœºæ¢°è‡‚åŠ¨ä½œå¤„ç†
        function processArmQueue(can) {
            if (armQueues[can].length === 0) {
                armProcessing[can] = false;
                return;
            }
            armProcessing[can] = true;
            const item = armQueues[can].shift();
            const y = item[1][0];
            const t = item[1][1];
            // ç»„åŒ…å¹¶å‘é€
            sendYSequenceWithCan(can, y, t).then(() => {
                setTimeout(() => {
                    processArmQueue(can);
                }, t * 1000 + 50);
            });
        }
        async function sendYSequenceWithCan(can, y, t) {
            // å›ºå®šx,z,rx,ry,rzï¼Œyå•ä½ä¸ºåº¦ï¼Œè½¬åƒåˆ†ä¹‹ä¸€åº¦
            const sendSeq = [[Math.round(y * 1000), t * 1000]];
            try {
                const response = await fetch('/api/arm/y_sequence', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({sequence: sendSeq, interface: can})
                });
                const data = await response.json();
                if (!response.ok) {
                    showMessage('æœºæ¢°è‡‚æŒ‡ä»¤å‘é€å¤±è´¥: ' + data.error, 'error');
                }
            } catch (error) {
                showMessage('æœºæ¢°è‡‚æŒ‡ä»¤å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>